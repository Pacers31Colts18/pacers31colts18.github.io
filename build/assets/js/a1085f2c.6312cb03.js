"use strict";(globalThis.webpackChunkpacers_31_colts_18_github_io=globalThis.webpackChunkpacers_31_colts_18_github_io||[]).push([[8429],{3119(e){e.exports=JSON.parse('{"permalink":"/blog/entra-grouprandomization","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2025-04-26-entra-pilotgrouprandomization/index.md","source":"@site/blog/2025-04-26-entra-pilotgrouprandomization/index.md","title":"Creating Intune Randomized Rollouts with Entra Group Membership","description":"Creating Intune Randomized Rollouts with Entra Group Membership","date":"2025-04-26T00:00:00.000Z","tags":[{"inline":false,"label":"Intune","permalink":"/blog/tags/intune","description":"Intune related posts."},{"inline":false,"label":"Entra","permalink":"/blog/tags/entra","description":"Entra related posts."},{"inline":false,"label":"PowerShell","permalink":"/blog/tags/powershell","description":"PowerShell related posts."},{"inline":false,"label":"Graph API","permalink":"/blog/tags/graph-api","description":"Microsoft Graph API related posts."}],"readingTime":7.51,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Creating Intune Randomized Rollouts with Entra Group Membership","description":"Creating Intune Randomized Rollouts with Entra Group Membership","slug":"entra-grouprandomization","date":"2025-04-26T00:00:00.000Z","tags":["intune","entra","powershell","graph-api"]},"unlisted":false,"prevItem":{"title":"CIS L1 Benchmarks in Intune with AVD Multi-Session Hosts","permalink":"/blog/cis-benchmarks-avd-multisession"},"nextItem":{"title":"An even better way to automate Entra Device Extension Attributes with Intune Remediation Scripts and Azure Automation","permalink":"/blog/entra-deviceextensionattributes-automation-better"}}')},4466(e,t,n){n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>h});var o=n(3119),r=n(4848),i=n(8453);const a={title:"Creating Intune Randomized Rollouts with Entra Group Membership",description:"Creating Intune Randomized Rollouts with Entra Group Membership",slug:"entra-grouprandomization",date:new Date("2025-04-26T00:00:00.000Z"),tags:["intune","entra","powershell","graph-api"]},s="Creating Intune Randomized Rollouts with Entra Group Membership",l={authorsImageUrls:[]},h=[{value:"Parameters, Declarations, Graph Check",id:"parameters-declarations-graph-check",level:2},{value:"Parameters",id:"parameters",level:3},{value:"Declarations",id:"declarations",level:3},{value:"Graph Check",id:"graph-check",level:3},{value:"Groups",id:"groups",level:2},{value:"Obtaining the Group",id:"obtaining-the-group",level:3},{value:"Obtaining Group Members",id:"obtaining-group-members",level:3},{value:"Randomization",id:"randomization",level:2},{value:"Building the PSCustomObject",id:"building-the-pscustomobject",level:2},{value:"Outputting the Results",id:"outputting-the-results",level:2},{value:"Conclusion",id:"conclusion",level:2}];function u(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"A walk through on how to create randomized rollouts for Intune deployments with Entra Groups using the Graph API."}),"\n",(0,r.jsx)(t.p,{children:"It's been a couple weeks now since I made my last post, with the weather starting to get nicer, it means more yard work and more random projects around the house. Next week is MMSMOA 2025, and I will be attending that with many team members. I think this is my 5th MMS, with my first one being in 2018 (I think). I'm really looking forward to it again and to see what new concepts everyone comes up with. I leave every year very excited, but also very worn out from all the days in the conference rooms, and the events that take place afterwards."}),"\n",(0,r.jsx)(t.p,{children:"With that said, I didn't want to go three weeks without posting anything, but was also struggling to come up with things to write about. Part of my struggle is seeing the already great content out there, and thinking that I can't truly add the value that other people provide. I know it's a bad head space to be in, and something to work through."}),"\n",(0,r.jsx)(t.p,{children:"In our org, we have around 40k devices. Rolling out policies in the Group Policy days was a little bit easier for us, as we weren't hitting every device at once (way too many forests). The great thing about Intune, is that we can hit all the devices at once. The bad thing about Intune, is we can hit all devices at once!"}),"\n",(0,r.jsx)(t.p,{children:"So the question became, how do we effectively roll out policy to devices and not run into issues? We have a pilot group, but pilot groups are hard to maintain, and not always the best representation of the org. Someone has to maintain that membership, and get buy in from users to be apart of the pilot group, and have enough members. Once we get past the initial internal piloting, and then the pilot group itself, we wanted a way to slowly rollout policies over a course of 2-3 weeks, to catch any issues should they come up."}),"\n",(0,r.jsx)(t.p,{children:"In our environment when rolling out large scale policies, we aim for a 1%/10%/25%/All Workstations. Typically this will run over the course of three weeks, in a schedule looking like this:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Week 1","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Monday: 1%"}),"\n",(0,r.jsx)(t.li,{children:"Thursday: 10%"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["Week 2","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Monday: 25%"}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(t.li,{children:["Week 3","\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"Monday: All Workstations"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"The thought being, after pilot groups, we are sitting at around 40% of devices covered in a random selection. If something were to happen after this rollout that causes an issue, it's probably more just bad luck."}),"\n",(0,r.jsx)(t.p,{children:"We have two variations of this function. One being for ConfigMgr. This is used for ConfigMgr rollouts (Configuration Baselines/Configuration Items) and Active Directory groups (Group Policy). The one I am going to show in this post, is for building Entra groups for Intune rollouts."}),"\n",(0,r.jsx)(t.p,{children:"In our org, something like this would go through the Change Control process, so we like to dump the output of this to a CSV file, then build the group membership after the fact. This could be easily tweaked to build the pilot groups themselves."}),"\n",(0,r.jsx)(t.h1,{id:"walking-through-the-function",children:"Walking through the function"}),"\n",(0,r.jsxs)(t.p,{children:["First, the function can be found on my ",(0,r.jsx)(t.a,{href:"https://github.com/Pacers31Colts18/Entra/blob/main/Export-EntraGroupPilotMembers.ps1",children:"Github"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"A lot of our code is very repeatable, and makes it easier for the next person to look at and pick up on."}),"\n",(0,r.jsx)(t.h2,{id:"parameters-declarations-graph-check",children:"Parameters, Declarations, Graph Check"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-powershell",children:'[CmdletBinding()]\n    Param(\n        [Parameter(Mandatory = $True)]\n        [string]$SourceEntraGroupName,\n        [Parameter(Mandatory = $True)]\n        [ValidateRange(1, 100)][int]$Percentage\n    )\n\n    #region Declarations\n    $FunctionName = $MyInvocation.MyCommand.Name.ToString()\n    $date = Get-Date -Format yyyyMMdd-HHmm\n    if ($outputdir.Length -eq 0) { $outputdir = $pwd }\n    $OutputFilePath = "$OutputDir\\$FunctionName-$date.csv"\n    $LogFilePath = "$OutputDir\\$FunctionName-$date.log"\n    $graphApiVersion = "beta"\n    $resultsArray = @()\n    #endregion\n    \n    # Microsoft Graph Connection check\n    if ($null -eq (Get-MgContext)) {\n        Write-Error "Connect to Graph"\n        Break\n    }\n'})}),"\n",(0,r.jsx)(t.h3,{id:"parameters",children:"Parameters"}),"\n",(0,r.jsxs)(t.p,{children:["First up is the parameter block. For $SourceEntraGroupName, we are building this off an Entra group that is already established. Example being, say you have an ",(0,r.jsx)(t.strong,{children:"SG - All Windows 11"})," group and you are looking to rollout a new policy to Windows 11 devices. You would input this group, then for $Percentage, provide the percentage of devices you want in your pilot group. We do have a ValidateRange check of 1-100. How is it a pilot if you have 100% of devices? It's not, sometimes we just like to use this as a cheat to quickly return all the group members."]}),"\n",(0,r.jsx)(t.h3,{id:"declarations",children:"Declarations"}),"\n",(0,r.jsx)(t.p,{children:"This is in almost all of our code, and makes the format of our logging, output files, and directories very repeatable. We set the $outputdir in our Powershell profiles to our preference location. Then use the $FunctionName parameter to name the log file in a proper manner."}),"\n",(0,r.jsx)(t.h3,{id:"graph-check",children:"Graph Check"}),"\n",(0,r.jsx)(t.p,{children:"Finally for this section, just a quick little check to see if you're connected to Graph, and if not, return an error."}),"\n",(0,r.jsx)(t.h2,{id:"groups",children:"Groups"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-powershell",children:'#region Obtain Group\n    try {\n        $uri = "https://graph.microsoft.com/$graphApiVersion/groups?`$filter=DisplayName eq \'$SourceEntraGroupName\'"\n        $group = (Invoke-MgGraphRequest -uri $uri -Method GET).value\n        Write-Output "Obtaining Group: $sourceEntraGroupName"\n    }\n    catch {\n        Write-Error "An error occurred : $_"\n    }\n    #end region\n\n    #region Obtain Group Members  \n    $resultCheck = @()   \n    try {\n        $uri = "https://graph.microsoft.com/$graphApiVersion/groups/$($group.Id)/members"\n        #pagination\n        do {\n            $groupmembers = (Invoke-MgGraphRequest -Uri $uri -Method GET)\n            $resultCheck += $groupmembers\n        \n            $uri = $groupmembers.\'@odata.nextLink\'\n        } while ($uri)\n        $groupmembers = $resultCheck.value\n\n        Write-Output "Obtaining \'$($group.DisplayName)\' with $($groupmembers.count) members." -ForegroundColor Cyan\n    }\n    catch {\n        Write-Error "An error occurred : $_"\n    }\n    #endregion\n'})}),"\n",(0,r.jsx)(t.h3,{id:"obtaining-the-group",children:"Obtaining the Group"}),"\n",(0,r.jsx)(t.p,{children:"From here, we're going to use the Graph API to get the group and all the details associated with it. In the beginning, we tried to stick with the Graph SDK cmdlets. Honestly, I've grown to hate them, and have reverted to using the API, or just relying on the Invoke-MgGraphRequest for nearly everything. I found the SDK to be a pain, with a lack of documentation, examples, and just super long cmdlet names. Finding them, and then finding that they don't work properly became a headache. Once the syntax of the API is figured out (which just takes some repetition), I find this way to be sooooo much easier. From what I've gathered, the SDK is just a wrapper for the API anyways, so I don't really see the point of it to be honest."}),"\n",(0,r.jsx)(t.h3,{id:"obtaining-group-members",children:"Obtaining Group Members"}),"\n",(0,r.jsxs)(t.p,{children:["Same concept here, once we have the Group details (from the $group variable), we can then obtain the membership using the ",(0,r.jsx)(t.strong,{children:"$group.id"}),". Based on the size of your Source Group, you might run into pagination issues. In simple terms, pagination is a limit on how much data you can get back at a time with Graph, so you're not slamming the system. More information can be found ",(0,r.jsx)(t.a,{href:"https://practical365.com/pagination-graph-sdk/",children:"here"})," and from ",(0,r.jsx)(t.a,{href:"https://learn.microsoft.com/en-us/graph/paging?tabs=http",children:"Microsoft"})]}),"\n",(0,r.jsx)(t.h2,{id:"randomization",children:"Randomization"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-powershell",children:'#region Randomization\n    $Decimal = $Percentage / 100\n    $NumberofMembers = [int]($($groupMembers).Count * $Decimal)\n    $NumberofMembers = [Math]::Ceiling($NumberofMembers)\n\n    Write-Output "Randomizing group and gathering $NumberofMembers workstations."\n    $GroupMembers = $GroupMembers | Sort-Object { Get-Random }\n    $GroupMembers = $GroupMembers | Select-Object -First $NumberofMembers\n\n    #endRegion\n'})}),"\n",(0,r.jsx)(t.p,{children:"Once the group members are returned, we then move onto the randomization of the script. What we're doing here is just simple math, and converting the percentage to a decimal and multiplying to get the count. From there, we are using a Sort-Object with Get-Random, which literally just does what it says and gets a random output of the devices. We're then selecting those members."}),"\n",(0,r.jsx)(t.h2,{id:"building-the-pscustomobject",children:"Building the PSCustomObject"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-powershell",children:"#region Build Object\n    foreach ($member in $groupMembers) {\n        $result = New-Object -TypeName PSObject -Property @{\n            EntraDeviceID = $member.deviceId\n            DeviceName    = $member.displayName\n        }\n        $ResultsArray += $result\n    }\n    #endregion\n"})}),"\n",(0,r.jsx)(t.p,{children:"Now we're building the data and will be outputting the data. Any property can be added here from what is stored on the device in Entra, but in my case, all I am looking for is the EntraDeviceID and DeviceName. DeviceName, mainly for change control purposes. EntraDeviceID, for when I create the group and add the members."}),"\n",(0,r.jsx)(t.h2,{id:"outputting-the-results",children:"Outputting the Results"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-powershell",children:' #region Results\n    if ($ResultsArray.Count -ge 1) {\n        $ResultsArray | Export-Csv -Path $outputfilepath -NoTypeInformation\n    }\n\n    # Test if output file was created\n    if (Test-Path $outputfilepath) {\n        Write-Output  "Output file = $outputfilepath."\n    }\n    else {\n        Write-Warning "No output file created."\n    }\n    #endregion\n}\n'})}),"\n",(0,r.jsx)(t.p,{children:"This is another repeatable section we have in our code. Like I said, we typically output a lot of our data to CSV files for change control purposes. This is a repeatable piece of code that we typically have in every output. What we are doing here is checking if the $ResultsArray (from the PSCustomObject) has any data, and if so, exporting the data to a CSV file, where the Path is in our declarations section. We are then testing to make sure the file was created successfully."}),"\n",(0,r.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(t.p,{children:"So now, we have a list of devices that are randomized, and based off a percentage from a source group. You can then repeat this process to build out other wave groups. Rather than have static groups to do the rollout, you can randomize it and get different results each time."}),"\n",(0,r.jsx)(t.p,{children:"Next week I'll be at MMS. If you happen to see me, be sure to say hi!"})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},8453(e,t,n){n.d(t,{R:()=>a,x:()=>s});var o=n(6540);const r={},i=o.createContext(r);function a(e){const t=o.useContext(i);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);